#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>

char*
loadInput(char* filename)
{
    FILE *fp;
    char *buffer;
    long file_size;

    fp = fopen(filename, "rb"); // open the file in binary mode
    if (fp == NULL) {
        printf("Error opening file.\n");
        return "_";
    }

    // find the size of the file
    fseek(fp, 0, SEEK_END); // seek to the end of the file
    file_size = ftell(fp); // get the current file position (which is the size of the file)
    rewind(fp); // rewind the file pointer to the beginning of the file

    // allocate memory for the buffer to hold the file contents
    buffer = (char*) malloc(file_size + 1); // add space for null terminator
    if (buffer == NULL) {
        printf("Error allocating memory.\n");
        return "_";
    }

    // read the entire file into the buffer
    fread(buffer, file_size, 1, fp);

    // add a null terminator to the end of the buffer
    buffer[file_size] = '\0';
    // print the contents of the buffer
    // printf("%s", buffer);
    // free the memory allocated for the buffer
    // free(buffer);

    // close the file
    fclose(fp);

    return buffer;
}

void
saveReult(char* input_path, char* reduced_input){
    FILE *fp;
    fp = fopen(input_path, "w");
    fprintf(fp, "%s", reduced_input);
    fclose(fp);
}

void 
timeout(int sig)
{
    if(sig==SIGALRM)
        puts("Time out!");
    exit(0);
}
void
keycontrol(int sig)
{
    if(sig==SIGINT)
        puts("CTRL+C pressed");
    exit(0);
}

int
main(int argc, char* argv[])
{
    // Used to store two ends of pipe
    int p2c[2];
    int c2p[2];
    // Used to store process id generated by fork()
    pid_t pid;

    // Used to get option(input, key error, ouput)
    int op; // option
    char input_path[30];
    char keyword[30];
    char output_path[30];

    // get option i, m, o
    while ( (op = getopt(argc, argv, "i:m:o:")) != -1 )
    {
        switch (op)
        {
            case 'i':
                memcpy(input_path, optarg, strlen(optarg));
                break;
            case 'm':
                memcpy(keyword, optarg, strlen(optarg));
                break;
            case 'o':
                memcpy(output_path, optarg, strlen(optarg));
                break;
            case '?':
                if(optopt == 'i' || optopt == 'm' || optopt == 'o')
                    printf("err : %c option requires string\n", optopt);
                else
                    printf("err : undetermined option\n");
                break;
        }
    }
    printf("%s\n", argv[argc-1]);
    printf("i : %s\n", input_path);
    printf("m : %s\n", keyword);
    printf("o : %s\n", output_path);

    signal(SIGALRM, timeout);
    signal(SIGINT, keycontrol);
    
    // load input test case to crashing_input
    // FILE *fp;
    // char original_input[];
    // fp = fopen(input_path, "r");
    // fscanf(fp, "%s", original_input);
    // fclose(fp);
    char * crashing_input = loadInput(input_path);

    // make pipe
    if (pipe(p2c) == -1 || pipe(c2p) == -1) 
    {
        fprintf(stderr, "Pipe Failed");
        return 1;
    }

    // fork()
    // parent-process
    // reduce()
    /*
    while()
    {
        for()
        {
            tokenizing -ifelse
            reduced_input <- head, tail
            pipe-write(reduced_input)
            alarm(3)
            err_msg = read()
            alarm(0)
            if errmsg == errkeyword
                return reduce
            else
                break
        }
        for()
        {
            token -> mid
            pipe-writE(mid)
            alarm(3)
            err_msg = read()
            alarm(0)
            if errmsg == errkeyword
                return reduce
            else
                break
        }
    }
    return ___;
    saveResut( reduced() )
    //child
    execl()
    */



    if ((pid = fork()) < 0)
    {
        fprintf(stderr, "fork Failed");
        return 1;
    }
    else if (pid > 0)
    {   // Parent process : delta debugging
        printf("parent: I'm parent\n");
        // close(p2c[0]); // Close reading end of first pipe
        
        char reduced_input[100];
        char error_message[100];
        // delta debugging algorithm
        for(int i=0;i<strlen(crashing_input)/2;i++){
            reduced_input[i] = crashing_input[i];
        }
 
        // Write input string and close writing end of first pipe
        write(p2c[1], reduced_input, strlen(reduced_input) + 1);
        alarm(3);

        close(p2c[1]);  // go to signal or terminal funciton
        wait(NULL);     // Wait for child to send a string
        close(c2p[1]);  // go to signal or terminal funciton

        read(c2p[0], error_message, 100);
        alarm(0);
        printf("parent: %s\n", error_message);
        close(c2p[0]); // go to signal or terminal funciton

        // check if error_message contains error_keyword
        if(strstr(error_message, keyword) != NULL) {   // error_message
            printf("Found!\n");
            // keep going debugging!
            saveReult(output_path, reduced_input);
        }
        else {
            printf("Not found!\n");
            
        }
        // return recursive delta debugging
    }
    else 
    {   // child process : run target program and get error message
        
        // execl(target_program);
        // get option
        
        close(p2c[1]); // Close writing end of first pipe
        dup2(c2p[1], 2);
        printf("child: I'm child\n");
 
        // Read a string using first pipe
        char reduced_input[100];
        read(p2c[0], reduced_input, 100);
        printf("child: %s\n", reduced_input);

        // sleep(3);

        // if(strcmp(reduced_input, crashing_input) != 0)
        fprintf(stderr, "child: std error\n");
        
        // Close both reading ends
        close(p2c[0]);
        close(c2p[0]);
 
        // Write concatenated string and close writing end
//        write(c2p[1], error_message, strlen(error_message) + 1);
        close(c2p[1]);
 
        exit(0);
    }

}
