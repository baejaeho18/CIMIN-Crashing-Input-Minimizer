#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>

char*
loadInput(char* filename)
{
    FILE *fp;
    char *buffer;
    long file_size;

    fp = fopen(filename, "rb"); // open the file in binary mode
    if (fp == NULL) {
        printf("Error opening file.\n");
        return "_";
    }

    // find the size of the file
    fseek(fp, 0, SEEK_END); // seek to the end of the file
    file_size = ftell(fp); // get the current file position (which is the size of the file)
    rewind(fp); // rewind the file pointer to the beginning of the file

    // allocate memory for the buffer to hold the file contents
    buffer = (char*) malloc(file_size + 1); // add space for null terminator
    if (buffer == NULL) {
        printf("Error allocating memory.\n");
        return "_";
    }

    // read the entire file into the buffer
    fread(buffer, file_size, 1, fp);

    // add a null terminator to the end of the buffer
    buffer[file_size] = '\0';
    // print the contents of the buffer
    // printf("%s", buffer);
    // free the memory allocated for the buffer
    // free(buffer);

    // close the file
    fclose(fp);

    return buffer;
}

void
saveReult(char* input_path, char* reduced_input){
    FILE *fp;
    fp = fopen(input_path, "w");
    fprintf(fp, "%s", reduced_input);
    fclose(fp);
}

void 
timeout(int sig)
{
    if(sig==SIGALRM)
        puts("Time out!");
    exit(0);
}
void
keycontrol(int sig)
{
    if(sig==SIGINT)
        puts("CTRL+C pressed");
    exit(0);
}

char*
reduce(char* original_input)
{
    // Used to store two ends of pipe
    int p2c[2];
    int c2p[2];

    // Used to store process id generated by fork()
    pid_t pid;

    int input_size = strlen(original_input) - 1;

    char* reduced_input;
    char* error_message = (char*)malloc(sizeof(char) * input_size);
    char* error_keyword = (char*)malloc(sizeof(char) * 10);         //strlen(keyword)

    while(input_size > 0)
    {
        printf("%d\n", input_size);
        for(int i=0; i<=strlen(original_input) - input_size; i++)
        {
            char* head;
            char* tail;
            if(0 > i-1)
                head = "";
            else{
                head = (char*)malloc(sizeof(char) * i);
                strncpy(head, original_input, i);
            }
            if(i+input_size > strlen(original_input)-1)
                tail = "";
            else{    // i = 0
                tail = (char*)malloc(sizeof(char) * (strlen(original_input)-i-input_size));
                strncpy(tail, original_input+i+input_size, strlen(original_input)-i-input_size);
            }

            // for test
            printf("(%d) head: %s, tail: %s\n", i, head, tail);

            reduced_input = (char*)malloc(sizeof(char) * (strlen(original_input)-input_size-1));
            strcat(reduced_input, head);
            strcat(reduced_input, tail);
            free(head);
            free(tail);

            // for test
            printf("(%d) reduced input:%s\n", i, reduced_input);

            // fork - pipe - write(head+tail);
            if ((pid = fork()) < 0)
            {
                fprintf(stderr, "fork Failed");
                return 1;
            }
            else if (pid > 0) // Parent process
            {
                // Write input string and close writing end of first pipe
                write(p2c[1], reduced_input, strlen(reduced_input) + 1);
                alarm(3);

                close(p2c[1]);  // go to signal or terminal function
                wait(NULL);     // Wait for child to send a string
                close(c2p[1]);  // go to signal or terminal function

                read(c2p[0], error_message, 100);
                alarm(0);
                printf("parent: %s\n", error_message);
                close(c2p[0]); // go to signal or terminal function

                // check if error_message contains error_keyword
                if(strstr(error_message, error_keyword) != NULL) {   // error_message
                    printf("Found!\n");
                    // keep going debugging!
                    saveReult(output_path, reduced_input); 
                }
                else {
                    printf("Not found!\n");
                    // recursive delta debugging
                    reduce(reduced_input);
                }
            }
            else // Child process
            { 
                execlp(target_p[0], target_p[0], target_p[1], target_p[2], target_p[3], target_p[4]);
            }
        }
        for(int i=0; i<=strlen(original_input)-input_size; i++)
        {
            char* mid;
            if(i > i+input_size-1)
            {
                mid = "";
            }
            else
            {
                mid = (char*)malloc(sizeof(char) * input_size);
                strncpy(mid, original_input+i, input_size);
            }
            printf("(%d) mid:%s\n", i, mid);

            // fork - pipe - write(mid)
            if ((pid = fork()) < 0)
            {
                fprintf(stderr, "fork Failed");
                return 1;
            }
            else if (pid > 0) // Parent process
            {
                // Write input string and close writing end of first pipe
                write(p2c[1], reduced_input, strlen(reduced_input) + 1);
                alarm(3);

                close(p2c[1]);  // go to signal or terminal function
                wait(NULL);     // Wait for child to send a string
                close(c2p[1]);  // go to signal or terminal function

                read(c2p[0], error_message, 100);
                alarm(0);
                printf("parent: %s\n", error_message);
                close(c2p[0]); // go to signal or terminal function

                // check if error_message contains error_keyword
                if(strstr(error_message, error_keyword) != NULL) {   // error_message
                    printf("Found!\n");
                    // keep going debugging!
                    saveReult(output_path, reduced_input); 
                }
                else {
                    printf("Not found!\n");
                    // recursive delta debugging
                    reduce(reduced_input);
                }
            }
            else // Child process
            { 
                execlp(target_p[0], target_p[0], target_p[1], target_p[2], target_p[3], target_p[4]);
            }

            free(mid);
        }
        input_size = input_size - 1;
    }
    free(reduced_input);
    free(error_keyword);
    free(error_message);
    
    return original_input;
}

int
main(int argc, char* argv[])
{
    // Used to store two ends of pipe
    int p2c[2];
    int c2p[2];
    // Used to store process id generated by fork()
    pid_t pid;

    // Used to get option(input, key error, ouput)
    int op; // option
    char input_path[30];
    char keyword[30];
    char output_path[30];
    char* target_p[5];
    // get option i, m, o
    while ( (op = getopt(argc, argv, ":i:m:o:")) != -1 )
    {
        switch (op)
        {
            case 'i':
                memcpy(input_path, optarg, strlen(optarg));
                break;
            case 'm':
                memcpy(keyword, optarg, strlen(optarg));
                break;
            case 'o':
                memcpy(output_path, optarg, strlen(optarg));
                break;
            case ':':
                printf("err : %c option requires string\n", optopt);
                return 0;
            case '?':
                printf("err : %c is undetermined option\n", optopt);
                return 0;
        }
    }
    if(argc < 7)    // how to change?
    {
        printf("err : three parameters must be given with options\n");
        return 0;
    }
    int cnt=0;
    while(optind < argc)
    {
        target_p[cnt] = argv[optind++];
    }
    printf("i : %s\n", input_path);
    printf("m : %s\n", keyword);
    printf("o : %s\n", output_path);
    for(int i=0;i<5;i++){
        if(target_p[i] != NULL)
            printf("%s ", target_p[i]);
    }
    printf("\n");

    signal(SIGALRM, timeout);
    signal(SIGINT, keycontrol);
    
    // load input test case to crashing_input
    // FILE *fp;
    // char original_input[];
    // fp = fopen(input_path, "r");
    // fscanf(fp, "%s", original_input);
    // fclose(fp);
    char * crashing_input = loadInput(input_path);

    // make pipe
    if (pipe(p2c) == -1 || pipe(c2p) == -1) 
    {
        fprintf(stderr, "Pipe Failed");
        return 1;
    }

    reduce(crashing_input);
}
