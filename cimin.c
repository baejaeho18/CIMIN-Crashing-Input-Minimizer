#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>

char output_path[30];
char error_keyword[30];
char* target_p[5];
int latest_reduced_input_size;
char* latest_reduced_input;

char*
loadInput(char* filename)
{
    FILE *fp;
    char *buffer;
    long file_size;

    fp = fopen(filename, "rb"); // open the file in binary mode
    if (fp == NULL)
    {
        printf("Error opening file.\n");
        return "";
    }
    // find the size of the file
    fseek(fp, 0, SEEK_END); // seek to the end of the file
    file_size = ftell(fp); // get the current file position (which is the size of the file)
    rewind(fp);
    // allocate memory for the buffer to hold the file contents
    buffer = (char*) malloc(file_size + 1); // add space for null terminator
    if (buffer == NULL)
    {
        printf("Error allocating memory.\n");
        return "";
    }

    fread(buffer, file_size, 1, fp);
    buffer[file_size] = '\0';
    fclose(fp);

    return buffer;
}

void
saveReult(){
    printf("Reduced_input size : %d\n", latest_reduced_input_size);

    FILE *fp;
    fp = fopen(output_path, "w");
    fprintf(fp, "%s", latest_reduced_input);
    fclose(fp);
    
    exit(0);
}

void 
timeout(int sig)
{
    if(sig==SIGALRM)
        puts("Time out!");

    saveResult();
}
void
keycontrol(int sig)
{
    if(sig==SIGINT)
        puts("CTRL+C pressed");

    saveResult();
}

char*
reduce(char* original_input)
{
    latest_reduced_input_size = strlen(original_input);
    latest_reduced_input = original_input;
    // Used to store two ends of pipe
    int p2c[2];
    int c2p[2];
    // Used to store process id generated by fork()
    pid_t pid;

    int input_size = strlen(original_input) - 1;
    char* reduced_input;
    char* error_message = (char*)malloc(sizeof(char) * 1024); // pipe read로 이동

    // make pipe
    if (pipe(p2c) == -1 || pipe(c2p) == -1) 
    {
        fprintf(stderr, "Pipe Failed");
        return 1;
    }

    while(input_size > 0)
    {
        printf("%d\n", input_size);
        for(int i=0; i<=strlen(original_input) - input_size; i++)
        {
            char* head;
            char* tail;
            if(0 > i-1)
                head = "";
            else{
                head = (char*)malloc(sizeof(char) * i);
                strncpy(head, original_input, i);
            }
            if(i+input_size > strlen(original_input)-1)
                tail = "";
            else{    // i = 0
                tail = (char*)malloc(sizeof(char) * (strlen(original_input)-i-input_size));
                strncpy(tail, original_input+i+input_size, strlen(original_input)-i-input_size);
            }

            // for test
            printf("(%d) head: %s, tail: %s\n", i, head, tail);

            reduced_input = (char*)malloc(sizeof(char) * (strlen(original_input)-input_size-1));
            strcat(reduced_input, head);
            strcat(reduced_input, tail);
            free(head);
            free(tail);

            // for test
            printf("(%d) reduced input:%s\n", i, reduced_input);

            // fork - pipe - write(head+tail);
            if ((pid = fork()) < 0)
            {
                fprintf(stderr, "fork Failed");
                return 1;
            }
            else if (pid > 0) // Parent process
            {
                close(p2c[0]);
                close(c2p[1]);
                write(p2c[1], reduced_input, strlen(reduced_input) + 1);
                alarm(3);
                // Wait for child to send a string
                wait(NULL);

                read(c2p[0], error_message, 100);
                alarm(0);
                close(p2c[1]);
                close(c2p[0]);
                printf("parent: %s\n", error_message);

                // check if error_message contains error_keyword
                if(strstr(error_message, error_keyword) != NULL)
                    break;
                else
                    return reduce(reduced_input);
            }
            else 
            {   // Child process
                execlp(target_p[0], target_p[0], target_p[1], target_p[2], target_p[3], target_p[4]);
            }
        }
        for(int i=0; i<=strlen(original_input)-input_size; i++)
        {
            char* mid;
            if(i > i+input_size-1)
            {
                mid = "";
            }
            else
            {
                mid = (char*)malloc(sizeof(char) * input_size);
                strncpy(mid, original_input+i, input_size);
            }

            strcat(reduced_input, mid);
            free(mid);
            printf("(%d) reduced_input:%s\n", i, reduced_input);

            // fork - pipe - write(mid)
            if ((pid = fork()) < 0)
            {
                fprintf(stderr, "fork Failed");
                return 1;
            }
            else if (pid > 0) // Parent process
            {
                close(p2c[0]);
                close(c2p[1]);
                write(p2c[1], reduced_input, strlen(reduced_input) + 1);
                alarm(3);
                // Wait for child to send a string
                wait(NULL);

                read(c2p[0], error_message, 100);
                alarm(0);
                close(p2c[1]);
                close(c2p[0]);
                printf("parent: %s\n", error_message);

                // check if error_message contains error_keyword
                if(strstr(error_message, error_keyword) != NULL)
                    break;
                else
                    return reduce(reduced_input);
            }
            else // Child process
            { 
                execlp(target_p[0], target_p[0], target_p[1], target_p[2], target_p[3], target_p[4]);
            }
        }
        input_size = input_size - 1;
    }
    free(reduced_input);
    free(error_keyword);
    free(error_message);

    return original_input;
}

int
main(int argc, char* argv[])
{
    // Used to get option(input, key error, ouput)
    int op; // option
    char input_path[30];
    // get option i, m, o
    while ( (op = getopt(argc, argv, ":i:m:o:")) != -1 )
    {
        switch (op)
        {
            case 'i':
                memcpy(input_path, optarg, strlen(optarg));
                break;
            case 'm':
                memcpy(error_keyword, optarg, strlen(optarg));
                break;
            case 'o':
                memcpy(output_path, optarg, strlen(optarg));
                break;
            case ':':
                printf("err : %c option requires string\n", optopt);
                return 0;
            case '?':
                printf("err : %c is undetermined option\n", optopt);
                return 0;
        }
    }
    if(argc < 7)    // how to change?
    {
        printf("err : three parameters must be given with options\n");
        return 0;
    }
    int cnt=0;
    while(optind < argc)
    {
        target_p[cnt] = argv[optind++];
    }
    // printf("i : %s\n", input_path);
    // printf("m : %s\n", error_keyword);
    // printf("o : %s\n", output_path);
    // for(int i=0;i<5;i++){
    //     if(target_p[i] != NULL)
    //         printf("%s ", target_p[i]);
    // }
    // printf("\n");

    signal(SIGALRM, timeout);   // output_path
    signal(SIGINT, keycontrol); // output_path
    
    char * crashing_input = loadInput(input_path);
    reduce(crashing_input);

    saveResult();
}
