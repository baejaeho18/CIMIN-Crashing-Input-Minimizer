#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>

#define MAX 4096

char reduced_input[MAX] ;
char output_path[30] ;
char error_keyword[30] ;
char * target_program ;

char *
loadInput(char * filename) 
{
    FILE * fp ;
    char original_input[MAX] ;
    size_t original_input_size = 0;

    fp = fopen(filename, "r") ;
    if (fp == NULL)
    {
        printf("Error opening file.\n") ;
        return NULL ;
    }

    while (!feof(fp))
    {
        original_input_size += fread(original_input + original_input_size, 1, MAX, fp) ;
    }
    fclose(fp) ;

    return original_input ;
}

void
saveResult()
{
    // printf("Reduced input size : %d\n", strlen(reduced_input)) ;
    size_t reduced_input_size = sizeof(reduced_input) ;
    FILE  * fp ;
    fp = fopen(output_path, "w") ;
    size_t written ;
    while (written < reduced_input_size)
    {
        written += fwrite(reduced_input + written, 1, reduced_input_size - written, fp) ;
    }
    fclose(fp) ;
    
    exit(0) ;
}

void 
timeout(int sig)
{
    if(sig == SIGALRM)
        puts("Time out!");

    saveResult();
    exit(0);
}

void
keycontrol(int sig)
{
    if(sig == SIGINT)
        puts("CTRL+C pressed");

    saveResult();
    exit(0);
}

char *
reduce(char * original_input)
{
    size_t reduced_input_size = sizeof(reduced_input) ;
    size_t s = reduced_input_size - 1 ;

    // pipe : to store two ends of pipe
    int p2c[2] ;
    int c2p[2] ;
    // fork : to store process id generated by fork()
    pid_t pid ;
    // to read error message
    char error_message[MAX * 2] ;
    size_t error_message_size ;

    // make pipe
    if (pipe(p2c) == -1 || pipe(c2p) == -1)
    {
        fprintf(stderr, "Pipe failed.\n") ;
        return NULL ;
    }

    while (s > 0)
    {
        for (int i = 0; i <= reduced_input_size - s - 1; i++) 
        {
            char head[MAX] ;
            char tail[MAX] ;
            size_t head_size ;
            size_t tail_size ;

            memcpy(head, reduced_input, i) ;
            head_size = i ;

            memcpy(tail, reduced_input + i + s, reduced_input_size - 1 - i - s + 1) ;
            tail_size = reduced_input_size - 1 - i - s + 1 ;

            char headtail[MAX] ;
            size_t headtail_size ;

            memcpy(headtail, head, head_size) ;
            memcpy(headtail + head_size, tail, tail_size) ;
            headtail_size = head_size + tail_size ;

            // fork - pipe - write (head + tail)
            if ((pid = fork()) < 0)
            {
                fprintf(stderr, "Fork failed for writing headtail.\n") ;
                return NULL ;
            }
            else if (pid > 0) 
            {   // parent process
                close(p2c[0]) ; // parent 의 읽는 쪽 닫기
                close(c2p[1]) ; // child 의 쓰는 쪽 닫기
                dup2(p2c[1], headtail) ; // send headtail to a child
                alarm(3) ; // start 3 sec alarm
                close(p2c[1]) ; // parent 의 쓰는 쪽 닫기
                wait(NULL) ; // wait for a child to reply
                /* while ((error_message_size = read(c2p[0], error_message, MAX * 2)) > 0) {
                    error_message[error_message_size + 1] = '0x0' ;
                } */
                read(c2p[0], error_message, 100);
                alarm(0) ; // finish 3 sec alarm
                close(c2p[0]) ;
                printf("parent with headtail: %s\n", error_message) ; /* checking */

                // check if error message contains error keyword
                if (strstr(error_message, error_keyword) != NULL)
                    break ;
                else
                    return reduce(headtail) ;
            }
            else 
            {   // child process
                close(c2p[0]) ; // child 의 읽는 쪽 닫기
                close(p2c[1]) ; // parent 의 쓰는 쪽 닫기
                dup2(c2p[1], 2) ; // child sends stderr to parent
                dup2(p2c[0], 0) ;
                read(p2c[0], headtail, headtail_size) ; /** TODO : while 추가 해서 빠짐 없이 잘 읽어오도록 */
                close(p2c[0]) ;
                execl(target_program, target_program, NULL) ;
            }
        }
        for (int i = 0; i <= reduced_input_size - 1; i++) 
        {
            char mid[MAX] ;
            size_t mid_size ;

            memcpy(mid, reduced_input + i, s + 1) ;
            mid_size = s + 1 ;

            // fork - pipe - write (mid)
            if ((pid = fork()) < 0)
            {
                fprintf(stderr, "Fork failed for writing mid.\n") ;
                return NULL ;
            }
            else if (pid > 0) 
            {   // parent process
                close(p2c[0]) ; // parent 의 읽는 쪽 닫기
                close(c2p[1]) ; // child 의 쓰는 쪽 닫기
                dup2(p2c[1], mid) ; // send reduced input to a child
                alarm(3) ; // start 3 sec alarm
                close(p2c[1]) ; // parent 의 쓰는 쪽 닫기
                wait(NULL) ; // wait for a child to reply
                while ((error_message_size = read(c2p[0], error_message, MAX * 2)) > 0) {
                    error_message[error_message_size + 1] = '0x0' ;
                }
                alarm(0) ; // finish 3 sec alarm
                close(c2p[0]) ;
                printf("parent with mid: %s\n", error_message) ; /* checking */

                // check if error message contains error keyword
                if (strstr(error_message, error_keyword) != NULL)
                    break ;
                else
                    return reduce(IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT) ;
            }
            else 
            {   // child process
                close(c2p[0]) ; // child 의 읽는 쪽 닫기
                close(p2c[1]) ; // parent 의 쓰는 쪽 닫기
                dup2(c2p[1], 2) ; // child sends stderr to parent
                dup2(p2c[0], 0) ;
                read(p2c[0], mid, mid_size) ; /** TODO : while 추가 해서 빠짐 없이 잘 읽어오도록 */
                close(p2c[0]) ;
                execl(target_program, target_program, NULL) ;
            }
        }
    }
    s--;

    return original_input ;
}

int
main(int argc, char* argv[])
{
    // to get option from the command (input, key error, ouput)
    int op ; // option
    char input_path[30] = "" ;
    //char* target_p_argu_1 = '\0';
    //char* target_p_argu_2 = "\0";

    // get option i, m, o
    while ( (op = getopt(argc, argv, ":i:m:o:")) != -1 )
    {
        switch (op)
        {
            case 'i' :
                memcpy(input_path, optarg, strlen(optarg)) ;
                break ;
            case 'm' :
                memcpy(error_keyword, optarg, strlen(optarg)) ;
                break ;
            case 'o' :
                memcpy(output_path, optarg, strlen(optarg)) ;
                break ;
            case ':' :
                printf("err : %c option requires string\n", optopt) ;
                return 0;
            case '?' :
                printf("err : %c is undetermined option\n", optopt) ;
                return 0;
        }
    }
    if (argc < 7)    // how to change?
    {
        printf("err : three parameters must be given with options\n") ;
        return 0 ;
    }
    if (argc == 7)
    {
        printf("err : no target program path\n") ;
        return 0 ;
    }
    else if (argc == 8)
    {
        target_program = argv[7] ;
    }
    else
    {
        printf("err : wrong arguments\n") ;
        return 0 ;
    }

    printf("i : %s\n", input_path) ;
    printf("m : %s\n", error_keyword) ;
    printf("o : %s\n", output_path) ;
    printf("p : %s\n", target_program) ;
    // printf("pa: %s %s\n", target_p_argu_1, target_p_argu_2);

    signal(SIGALRM, timeout) ;   // output_path
    signal(SIGINT, keycontrol) ; // output_path
    
    char * crashing_input = loadInput(input_path);
    // crashing_input = "abcdef";
    printf("%s\n", crashing_input);
    reduce(crashing_input);

    saveResult();
}